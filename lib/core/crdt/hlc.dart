/// Hybrid Logical Clock (HLC) implementation for distributed event ordering.
///
/// HLC combines physical time with a logical counter to provide:
/// - Monotonically increasing timestamps
/// - Causal ordering of events
/// - Bounded drift from physical time
///
/// Based on the paper: "Logical Physical Clocks and Consistent Snapshots
/// in Globally Distributed Databases" by Kulkarni et al.
library;

import 'dart:math';

/// A Hybrid Logical Clock timestamp.
///
/// Consists of:
/// - [physicalTime]: Wall clock time in milliseconds
/// - [counter]: Logical counter for events at same physical time
/// - [nodeId]: Unique identifier for the node (for tie-breaking)
class HybridTimestamp implements Comparable<HybridTimestamp> {
  /// Physical time component (milliseconds since epoch).
  final int physicalTime;

  /// Logical counter for ordering events at the same physical time.
  final int counter;

  /// Node identifier for deterministic tie-breaking.
  final String nodeId;

  const HybridTimestamp({
    required this.physicalTime,
    required this.counter,
    required this.nodeId,
  });

  /// Creates a timestamp from a packed string format.
  ///
  /// Format: `{physicalTime}-{counter}-{nodeId}`
  factory HybridTimestamp.parse(String packed) {
    final parts = packed.split('-');
    if (parts.length < 3) {
      throw FormatException('Invalid HybridTimestamp format: $packed');
    }
    return HybridTimestamp(
      physicalTime: int.parse(parts[0]),
      counter: int.parse(parts[1]),
      nodeId: parts.sublist(2).join('-'), // nodeId may contain dashes
    );
  }

  /// Creates a zero timestamp (epoch).
  factory HybridTimestamp.zero(String nodeId) {
    return HybridTimestamp(physicalTime: 0, counter: 0, nodeId: nodeId);
  }

  /// Packs the timestamp into a string for storage/transmission.
  String pack() => '$physicalTime-$counter-$nodeId';

  @override
  int compareTo(HybridTimestamp other) {
    // Compare physical time first
    if (physicalTime != other.physicalTime) {
      return physicalTime.compareTo(other.physicalTime);
    }
    // Then compare counter
    if (counter != other.counter) {
      return counter.compareTo(other.counter);
    }
    // Finally, compare node ID for deterministic ordering
    return nodeId.compareTo(other.nodeId);
  }

  /// Returns true if this timestamp is strictly before [other].
  bool operator <(HybridTimestamp other) => compareTo(other) < 0;

  /// Returns true if this timestamp is before or equal to [other].
  bool operator <=(HybridTimestamp other) => compareTo(other) <= 0;

  /// Returns true if this timestamp is strictly after [other].
  bool operator >(HybridTimestamp other) => compareTo(other) > 0;

  /// Returns true if this timestamp is after or equal to [other].
  bool operator >=(HybridTimestamp other) => compareTo(other) >= 0;

  @override
  bool operator ==(Object other) =>
      other is HybridTimestamp &&
      physicalTime == other.physicalTime &&
      counter == other.counter &&
      nodeId == other.nodeId;

  @override
  int get hashCode => Object.hash(physicalTime, counter, nodeId);

  @override
  String toString() => 'HybridTimestamp($physicalTime, $counter, $nodeId)';
}

/// A Hybrid Logical Clock that generates monotonically increasing timestamps.
///
/// Usage:
/// ```dart
/// final clock = HybridLogicalClock(nodeId: 'node-1');
///
/// // Generate timestamp for local event
/// final ts1 = clock.now();
///
/// // Receive remote timestamp and update clock
/// final remoteTs = HybridTimestamp.parse(receivedData);
/// clock.receive(remoteTs);
///
/// // Generate next timestamp (will be after remoteTs)
/// final ts2 = clock.now();
/// ```
class HybridLogicalClock {
  /// Unique identifier for this node.
  final String nodeId;

  /// Function to get current physical time (injectable for testing).
  final int Function() _getPhysicalTime;

  /// Maximum allowed drift from physical time (milliseconds).
  final int maxDrift;

  /// Last timestamp generated by this clock.
  HybridTimestamp _lastTimestamp;

  /// Creates a new HLC with the given node ID.
  ///
  /// [nodeId] must be unique across all nodes in the system.
  /// [maxDrift] is the maximum allowed drift from physical time (default: 1 minute).
  /// [physicalTimeFn] can be provided for testing (defaults to DateTime.now()).
  HybridLogicalClock({
    required this.nodeId,
    this.maxDrift = 60000, // 1 minute default
    int Function()? physicalTimeFn,
  })  : _getPhysicalTime =
            physicalTimeFn ?? (() => DateTime.now().millisecondsSinceEpoch),
        _lastTimestamp = HybridTimestamp.zero(nodeId);

  /// Returns the last timestamp generated by this clock.
  HybridTimestamp get lastTimestamp => _lastTimestamp;

  /// Generates a new timestamp for a local event.
  ///
  /// The returned timestamp is guaranteed to be:
  /// - Greater than any previously generated timestamp
  /// - Greater than any received remote timestamp
  /// - Within [maxDrift] of the current physical time
  ///
  /// Throws [ClockDriftException] if the clock has drifted too far.
  HybridTimestamp now() {
    final physicalNow = _getPhysicalTime();

    // Check for excessive drift
    if (_lastTimestamp.physicalTime - physicalNow > maxDrift) {
      throw ClockDriftException(
        'Clock drift exceeded maximum: ${_lastTimestamp.physicalTime - physicalNow}ms > ${maxDrift}ms',
      );
    }

    final newPhysicalTime = max(physicalNow, _lastTimestamp.physicalTime);
    final newCounter = (newPhysicalTime == _lastTimestamp.physicalTime)
        ? _lastTimestamp.counter + 1
        : 0;

    _lastTimestamp = HybridTimestamp(
      physicalTime: newPhysicalTime,
      counter: newCounter,
      nodeId: nodeId,
    );

    return _lastTimestamp;
  }

  /// Updates the clock after receiving a remote timestamp.
  ///
  /// This ensures that subsequent calls to [now] will return timestamps
  /// that are greater than both local and remote timestamps.
  ///
  /// Throws [ClockDriftException] if the remote timestamp is too far ahead.
  void receive(HybridTimestamp remote) {
    final physicalNow = _getPhysicalTime();

    // Check for excessive drift from remote
    if (remote.physicalTime - physicalNow > maxDrift) {
      throw ClockDriftException(
        'Remote clock drift exceeded maximum: ${remote.physicalTime - physicalNow}ms > ${maxDrift}ms',
      );
    }

    final maxPhysical =
        max(physicalNow, max(_lastTimestamp.physicalTime, remote.physicalTime));

    int newCounter;
    if (maxPhysical == _lastTimestamp.physicalTime &&
        maxPhysical == remote.physicalTime) {
      // All three are equal, take max counter + 1
      newCounter = max(_lastTimestamp.counter, remote.counter) + 1;
    } else if (maxPhysical == _lastTimestamp.physicalTime) {
      // Local is max, increment local counter
      newCounter = _lastTimestamp.counter + 1;
    } else if (maxPhysical == remote.physicalTime) {
      // Remote is max, use remote counter + 1
      newCounter = remote.counter + 1;
    } else {
      // Physical time advanced, reset counter
      newCounter = 0;
    }

    _lastTimestamp = HybridTimestamp(
      physicalTime: maxPhysical,
      counter: newCounter,
      nodeId: nodeId,
    );
  }

  /// Merges with another HLC state (useful for restoring from storage).
  ///
  /// After merge, this clock's state will be at least as advanced as [other].
  void merge(HybridLogicalClock other) {
    if (_lastTimestamp < other._lastTimestamp) {
      receive(other._lastTimestamp);
    }
  }
}

/// Exception thrown when clock drift exceeds the maximum allowed.
class ClockDriftException implements Exception {
  final String message;
  ClockDriftException(this.message);

  @override
  String toString() => 'ClockDriftException: $message';
}
